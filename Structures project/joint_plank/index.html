<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setting up world</title>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/ammo.js"></script>
    <script src = "js/OrbitControls.js"></script>
   
    <script>

        //variable declaration
        let physicsWorld, controls, scene, camera, renderer, rigidBodies = []
        let colGroupPlane = 1, colGroupPlankBlocks = 1;

        window.addEventListener('resize', onWindowResize, false);
        //Ammojs Initialization
        Ammo().then( Init )
        
        function Init()
        {
            
            //code goes here
            tmpTrans = new Ammo.btTransform();
            setupPhysicsWorld();
            setupGraphics();
            
            createBlock();
            createPlank();
            //createTestBlcok();
            //createBall();
            renderFrame();

        }
    
        function setupPhysicsWorld()
        {
            let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
                overlappingPairCache = new Ammo.btDbvtBroadphase(),
                solver = new Ammo.btSequentialImpulseConstraintSolver();

            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));
        }
        
        function setupGraphics()
        {
            //create clock for timing
            clock = new THREE.Clock();

            //create the scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xbfd1e5 );

            //create camera
            camera = new THREE.PerspectiveCamera( 17, window.innerWidth / window.innerHeight, 0.2, 5000 );
            camera.position.set( 50, 180, -170 );
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            //Add hemisphere light
            let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
            hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
            hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
            hemiLight.position.set( 0, 50, 0 );
            scene.add( hemiLight );

            //Add directional light
            let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
            dirLight.color.setHSL( 0.1, 1, 0.95 );
            dirLight.position.set( -1, 1.75, 1 );
            dirLight.position.multiplyScalar( 100 );
            scene.add( dirLight );

            dirLight.castShadow = true;

            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;

            let d = 50;

            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 13500;

            //Setup the renderer
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setClearColor( 0xbfd1e5 );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
                                                 
            renderer.shadowMap.enabled = true;
        }
         
        //This is a function which will be called a an event listener to resize the tab.
        function onWindowResize(){
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight);
        }

        function setUpControls(){
            const controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventlistener( 'change', render );
            controls.minDistance = 20;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI/2;
        }

        function renderFrame()
        {
            let deltaTime = clock.getDelta();
            //controls.update();
            updatePhysics(deltaTime);
            renderer.render( scene, camera );
            requestAnimationFrame( renderFrame );
        }
        
        function createBlock()
        {
            let pos = {x: 0, y: 0, z: 0};
            let scale = {x: 50, y: 2, z: 50};
            let quat = {x: 0, y: 0, z: 0, w: 1};
            let mass = 0;

            //threeJS Section
            let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x3c4145}));

            blockPlane.position.set(pos.x, pos.y, pos.z);
            blockPlane.scale.set(scale.x, scale.y, scale.z);

            blockPlane.castShadow = true;
            blockPlane.receiveShadow = true;

            scene.add(blockPlane);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );

            physicsWorld.addRigidBody( body, colGroupPlane, colGroupPlankBlocks );
            
        }

        function createPlank(){
            let width = 4;  // This is the width of the plank in inches
            let length = 5;  // This is the length of the plank in inches
            let posy = 10;
            let mass = 1;

            let scale = { x:1,y:1,z:1}; 

            // Have to create a 2d array to store the block 
            // to create joint connection for them later
            let blockArray = [];

            for (let i = 0; i < length; i++){
                blockArray[i] = [];
                for ( let x = 0; x < width; x++){
                    blockArray[i][x] = null;
                }
            }

            for( let z = 0; z < length; z++ ){  // nested for loop goes though 
                for( let x = 0; x < width; x++ ){
                    let block = new THREE.Mesh( new THREE.BoxBufferGeometry(1,1,1), new THREE.MeshPhongMaterial({color: 0x964B00}) );
                    block.position.set(-25/*x-3*/, posy, -24/*z-10*/);

                    block.castShadow = true;
                    block.receiveShadow = true;

                    scene.add( block );

                    //Ammojs Section
                    let transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin( new Ammo.btVector3( /*x-3*/-25, posy, -24/*z-10 */) );
                    transform.setRotation( new Ammo.btQuaternion( 0, 0, 0, 1 ) );
                    let motionState = new Ammo.btDefaultMotionState( transform );

                    let blockShape = new Ammo.btBoxShape(new Ammo.btVector3( 0,0,0 ));
                    blockShape.setMargin( 0.05 );

                    let localInertia = new Ammo.btVector3( 0, 0, 0 );
                    blockShape.calculateLocalInertia( mass, localInertia );

                    let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, blockShape, localInertia );
                    let body = new Ammo.btRigidBody( rbInfo );


                    physicsWorld.addRigidBody( body, colGroupPlankBlocks, colGroupPlane );
                        
                    block.userData.physicsBody = body;

                    rigidBodies.push( block );

                    blockArray[z][x] = body;
                }
            }

            // This is a nested for loop that iterates through each block in each row and 
            // adds point to point constraints between them
            for( let z = 0; z < blockArray.length -1; z++ ){
                
                for ( let x = 0; x < blockArray[z].length - 1; x++){
                    let blockPivot1 = new Ammo.btVector3( scale.x * 0.5, 1, 1 );
                    let blockPivot2 = new Ammo.btVector3( - scale.x * 0.5, 1, 1);
                    let p2p = new Ammo.btPoint2PointConstraint( blockArray[z][x], blockArray[z][x+1], blockPivot1, blockPivot2 );
                    physicsWorld.addConstraint( p2p, false );
                    
                }
            }

            // This is a nested for loop that iterates through each block in each column 
            // and connects them with p2p constraints.
            // for loop through each width
            // for loop for every item in height -1
            // add constraint for first item connected in column connected with the next row.

            for( let z = 0; z < width; z ++){  // need to check if this works.
                for ( let x = 0; x < length -1; x++ ){
                    let blockPivot1 = new Ammo.btVector3( 1, 1, scale.x * 0.5 );
                    let blockPivot2 = new Ammo.btVector3( 1, 1, - scale.x * 0.5);
                    let p2p = new Ammo.btPoint2PointConstraint( blockArray[z][x], blockArray[z+1][x], blockPivot1, blockPivot2 );
                    physicsWorld.addConstraint( p2p, false );
                }
            }

            // Creating a static block to test if my joints work

            let mass1 = 0;

            //threeJS Section
            let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x3c4145}));

            blockPlane.position.set(-3,11,-10);
            blockPlane.scale.set(1,1,1);

            blockPlane.castShadow = true;
            blockPlane.receiveShadow = true;

            scene.add(blockPlane);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( -3, 11, -10 ) );
            transform.setRotation( new Ammo.btQuaternion( 1,1,1 ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btBoxShape( new Ammo.btVector3( 1,1,1 ) );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass1, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass1, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );

            physicsWorld.addRigidBody( body, colGroupPlane, colGroupPlankBlocks );

            let blockPivot1 = new Ammo.btVector3( 1, -0.5, 1 );
            let blockPivot2 = new Ammo.btVector3( 1, 0.5, 1);
            let p2p = new Ammo.btPoint2PointConstraint( blockPivot1, blockPivot2, body, blockArray[0][0] );
            physicsWorld.addConstraint( p2p, false );
        }


        function createBall(){  // This is just a example function for creating an object in ammo
    
            let pos = {x: 0, y: 20, z: 0};
            let radius = 2;
            let quat = {x: 0, y: 0, z: 0, w: 1};
            let mass = 1;

            //threeJS Section
            let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xff0505}));

            ball.position.set(pos.x, pos.y, pos.z);
            
            ball.castShadow = true;
            ball.receiveShadow = true;

            scene.add(ball);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btSphereShape( radius );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );


            physicsWorld.addRigidBody( body, colGroupPlankBlocks, colGroupPlane );
            
            ball.userData.physicsBody = body;
            rigidBodies.push(ball);
        }

                            
        function updatePhysics( deltaTime )
        {
            // Step world
            physicsWorld.stepSimulation( deltaTime, 10 );
    
            // Update rigid bodies
            for ( let i = 0; i < rigidBodies.length; i++ )
            {
                let objThree = rigidBodies[ i ];
                let objAmmo = objThree.userData.physicsBody;
                let ms = objAmmo.getMotionState();
                if ( ms )
                {
                    ms.getWorldTransform( tmpTrans );
                    let p = tmpTrans.getOrigin();
                    let q = tmpTrans.getRotation();
                    objThree.position.set( p.x(), p.y(), p.z() );
                    objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
                }
            }
        }
    </script>
</body>
</html>