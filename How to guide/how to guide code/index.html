<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setting up world</title>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/ammo.js"></script>
    <script>
        
        //variable declaration
        let physicsWorld, controls, scene, camera, renderer, rigidBodies = []
        let softBodies = [];
        let colGroupPlane = 1, colGroupRedBall = 1, colGroupGreenball = 2;

        window.addEventListener('resize', onWindowResize, false);
        //Ammojs Initialization
        Ammo().then( Init )
        
        function Init()
        {
            //code goes here
            tmpTrans = new Ammo.btTransform();
            setupPhysicsWorld();
            setupGraphics();
            createBlock();
            //createPlank();
            //createBall();
            //renderer.render(scene, camera);
            //createGreenBall();
            //createRedBall();
           // createSoftBody();
            //createSoftBody2();
            createConstraint();
            renderFrame();
        }

        function createSoftBody2(){
            // Create soft volumes
            var volumeMass = 15;

            var sphereGeometry = new THREE.SphereBufferGeometry( 1.5, 40, 25 );
            sphereGeometry.translate( 5, 5, 0 );
            createSoftVolume( sphereGeometry, volumeMass, 250 );

            var boxGeometry = new THREE.BufferGeometry().fromGeometry( new THREE.BoxGeometry( 1, 1, 5, 4, 4, 20 ) );
            boxGeometry.translate( -2, 5, 0 );
            createSoftVolume( boxGeometry, volumeMass, 120 );
        }

        function createSoftVolume( bufferGeom, mass, pressure ) {

            processGeometry( bufferGeom );

            var volume = new THREE.Mesh( bufferGeom, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
            volume.castShadow = true;
            volume.receiveShadow = true;
            volume.frustumCulled = false;
            scene.add( volume );

            // Volume physic object

            var volumeSoftBody = softBodyHelpers.CreateFromTriMesh(
                physicsWorld.getWorldInfo(),
                bufferGeom.ammoVertices,
                bufferGeom.ammoIndices,
                bufferGeom.ammoIndices.length / 3,
                true );

            var sbConfig = volumeSoftBody.get_m_cfg();
            sbConfig.set_viterations( 40 );
            sbConfig.set_piterations( 40 );
        }
    
        function setupPhysicsWorld()
        {
            let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
                overlappingPairCache = new Ammo.btDbvtBroadphase(),
                solver = new Ammo.btSequentialImpulseConstraintSolver();

            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));
        }
        
        function setupGraphics()
        {
            //create clock for timing
            clock = new THREE.Clock();

            //create the scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xbfd1e5 );

            //create camera
            camera = new THREE.PerspectiveCamera( 17, window.innerWidth / window.innerHeight, 0.2, 5000 );
            camera.position.set( 50, 180, -170 );
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            //Add hemisphere light
            let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
            hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
            hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
            hemiLight.position.set( 0, 50, 0 );
            scene.add( hemiLight );

            //Add directional light
            let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
            dirLight.color.setHSL( 0.1, 1, 0.95 );
            dirLight.position.set( -1, 1.75, 1 );
            dirLight.position.multiplyScalar( 100 );
            scene.add( dirLight );

            dirLight.castShadow = true;

            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;

            let d = 50;

            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 13500;

            //Setup the renderer
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setClearColor( 0xbfd1e5 );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
                                                 
            renderer.shadowMap.enabled = true;
        }
         
        //This is a function which will be called a an event listener to resize the tab.
        function onWindowResize(){
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight);
        }

        function setUpControls(){
            const controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventlistener( 'change', render );
            controls.minDistance = 20;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI/2;
        }

        function renderFrame()
        {
            let deltaTime = clock.getDelta();
            //controls.update();
            updatePhysics(deltaTime);
            renderer.render( scene, camera );
            requestAnimationFrame( renderFrame );
        }
        
        function createBlock()
        {
            let pos = {x: 0, y: 0, z: 0};
            let scale = {x: 50, y: 2, z: 50};
            let quat = {x: 0, y: 0, z: 0, w: 1};
            let mass = 0;

            //threeJS Section
            let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0x3c4145}));

            blockPlane.position.set(pos.x, pos.y, pos.z);
            blockPlane.scale.set(scale.x, scale.y, scale.z);

            blockPlane.castShadow = true;
            blockPlane.receiveShadow = true;

            scene.add(blockPlane);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );

            physicsWorld.addRigidBody( body, colGroupPlane, colGroupGreenball );
            
        }

        // This method will create a sample soft body object
        function createSoftBody(){

        }

        function createConstraint(){
            // These are the positions of the two objects that will be connected
            let pos1 = {x: -1, y: 15, z: 0};
            let pos2 = {x: -1, y: 10, z: 0};

            // These are the properties for the two objects
            let radius = 2; // radius creating the sphere
            let scale = {x: 5, y: 2, z: 2};  // scale for creating the cube
            let quat = {x: 0, y: 0, z: 0, w: 1};  // This is the rotation, both objects will share this
            let mass1 = 0;  // this is the mass for the first object the ball. it is 0 therefore it is a static rigid body
            let mass2 = 1;  // mass for the cube object making is dynamic

            // world transform value.
            let transform = new Ammo.btTransform();  

            //Sphere Graphics
            let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xb846db}));

            ball.position.set(pos1.x, pos1.y, pos1.z);

            ball.castShadow = true;
            ball.receiveShadow = true;

            scene.add(ball);


            //Sphere Physics
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos1.x, pos1.y, pos1.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let sphereColShape = new Ammo.btSphereShape( radius );
            sphereColShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            sphereColShape.calculateLocalInertia( mass1, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass1, motionState, sphereColShape, localInertia );
            let sphereBody = new Ammo.btRigidBody( rbInfo );

            physicsWorld.addRigidBody( sphereBody);  // This will make the two object collide

            ball.userData.physicsBody = sphereBody;  
            rigidBodies.push(ball); 
            

            //Block Graphics
            let block = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf78a1d}));

            block.position.set(pos2.x, pos2.y, pos2.z);
            block.scale.set(scale.x, scale.y, scale.z);

            block.castShadow = true;
            block.receiveShadow = true;

            scene.add(block);


            //Block Physics
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos2.x, pos2.y, pos2.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            motionState = new Ammo.btDefaultMotionState( transform );

            let blockColShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
            blockColShape.setMargin( 0.05 );

            localInertia = new Ammo.btVector3( 0, 0, 0 );
            blockColShape.calculateLocalInertia( mass2, localInertia );

            rbInfo = new Ammo.btRigidBodyConstructionInfo( mass2, motionState, blockColShape, localInertia );
            let blockBody = new Ammo.btRigidBody( rbInfo );

            physicsWorld.addRigidBody( blockBody );
            
            block.userData.physicsBody = blockBody;
            rigidBodies.push(block);



            //Create Joints
            // the pivots of the two objects show where the two objects will connect
            // we use vector 3 to represent it (0, 0, 0 ) vector represents the center of the 
            // object, therefore when we want to get to the side of the object we need to use
            // half that objects length. 
            let spherePivot = new Ammo.btVector3( 0, - radius, 0 );  // since the sphere is the top object, it uses - radius as the sphere 
            // pivot connects to the object below it on the y axis
            let blockPivot = new Ammo.btVector3( - scale.x * 0.5, 1, 0 );  // its the same concept for the cube since the sphere is above it 
            // we use half its height. 

            let p2p = new Ammo.btConeTwistConstraint( sphereBody, blockBody, spherePivot, blockPivot);  // this defines the p2p object
            // its takes 4 parameters the first body, second body, first bodies pivot, and second bodies pivot.
            physicsWorld.addConstraint( p2p, false );  // this adds the p2p constraint defined above to the world.

        }

        function createPlank(){
            let width = 2;  // This is the width of the plank in inches
            let length = 4;  // This is the length of the plank in inches
            let posy = 10;
            let mass = 1;

            let scale = { x:1,y:1,z:1}; 

            // Have to create a 2d array to store the block 
            // to create joint connection for them later
            let blockArray = [];

            for (let i = 0; i < length; i++){
                blockArray[i] = [];
                for ( let x = 0; x < width; x++){
                    blockArray[i][x] = null;
                }
            }
            console.log(blockArray);

            for( let z = 0; z < length; z++ ){  // nested for loop goes though 
                for( let x = 0; x < width; x++ ){
                    let block = new THREE.Mesh( new THREE.BoxBufferGeometry(1,1,1), new THREE.MeshPhongMaterial({color: 0x964B00}) );
                    block.position.set(x-3, posy, z-10);

                    block.castShadow = true;
                    block.receiveShadow = true;

                    scene.add( block );

                    //Ammojs Section
                    let transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin( new Ammo.btVector3( x-3, posy, z-10 ) );
                    transform.setRotation( new Ammo.btQuaternion( 0, 0, 0, 1 ) );
                    let motionState = new Ammo.btDefaultMotionState( transform );

                    let blockShape = new Ammo.btBoxShape(new Ammo.btVector3( 0,0,0 ));
                    blockShape.setMargin( 0.05 );

                    let localInertia = new Ammo.btVector3( 0, 0, 0 );
                    blockShape.calculateLocalInertia( mass, localInertia );

                    let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, blockShape, localInertia );
                    let body = new Ammo.btRigidBody( rbInfo );


                    physicsWorld.addRigidBody( body, colGroupPlankBlocks, colGroupPlane );
                        
                    block.userData.physicsBody = body;

                    rigidBodies.push( block );

                    blockArray[z][x] = body;
                }
            }

            // This is a nested for loop that iterates through each block in each row and 
            // adds point to point constraints between them
            for( let z = 0; z < blockArray.length -1; z++ ){
                
                for ( let x = 0; x < blockArray[z].length - 1; x++){
                    let blockPivot1 = new Ammo.btVector3( scale.x * 0.5, 1, 1 );
                    let blockPivot2 = new Ammo.btVector3( - scale.x * 0.5, 1, 1);
                    let p2p = new Ammo.btPoint2PointConstraint( blockArray[z][x], blockArray[z][x+1], blockPivot1, blockPivot2 );
                    physicsWorld.addConstraint( p2p, false );
                    
                }
            }

            // This is a nested for loop that iterates through each block in each column 
            // and connects them with p2p constraints.
            // for loop through each width
            // for loop for every item in height -1
            // add constraint for first item connected in column connected with the next row.

            for( let z = 0; z < width; z ++){  // need to check if this works.
                for ( let x = 0; x < length -1; x++ ){
                    let blockPivot1 = new Ammo.btVector3( 1, 1, scale.x * 0.5 );
                    let blockPivot2 = new Ammo.btVector3( 1, 1, - scale.x * 0.5);
                    let p2p = new Ammo.btPoint2PointConstraint( blockArray[z][x], blockArray[z+1][x], blockPivot1, blockPivot2 );
                    physicsWorld.addConstraint( p2p, false );
                }
            }
        }


        function createGreenBall(){  // creating the green ball.
    
            let pos = {x: 3, y: 20, z: 0};
            let radius = 2;
            let quat = {x: 0, y: 0, z: 0, w: 1};
            let mass = 1;

            //threeJS Section
            let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0x00FF00}));

            ball.position.set(pos.x, pos.y, pos.z);
            
            ball.castShadow = true;
            ball.receiveShadow = true;

            scene.add(ball);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btSphereShape( radius );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );


            physicsWorld.addRigidBody( body, colGroupGreenball, colGroupPlane );
            
            ball.userData.physicsBody = body;
            rigidBodies.push(ball);
        }

        function createRedBall(){  // creating the red ball
            let pos = {x: -3, y: 20, z: 0};  
            let radius = 2;  
            let quat = {x: 0, y: 0, z: 0, w: 1};  
            let mass = 1;

            //threeJS Section
            let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xff0505}));

            ball.position.set(pos.x, pos.y, pos.z);
            
            ball.castShadow = true;
            ball.receiveShadow = true;

            scene.add(ball);


            //Ammojs Section
            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
            transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
            let motionState = new Ammo.btDefaultMotionState( transform );

            let colShape = new Ammo.btSphereShape( radius );
            colShape.setMargin( 0.05 );

            let localInertia = new Ammo.btVector3( 0, 0, 0 );
            colShape.calculateLocalInertia( mass, localInertia );

            let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
            let body = new Ammo.btRigidBody( rbInfo );


            physicsWorld.addRigidBody( body, colGroupRedBall, colGroupPlane);
            
            ball.userData.physicsBody = body;
            rigidBodies.push(ball);
        }

                            
        function updatePhysics( deltaTime )
        {
            // Step world
            physicsWorld.stepSimulation( deltaTime, 10 );
    
            // Update rigid bodies
            for ( let i = 0; i < rigidBodies.length; i++ )
            {
                let objThree = rigidBodies[ i ];
                let objAmmo = objThree.userData.physicsBody;
                let ms = objAmmo.getMotionState();
                if ( ms )
                {
                    ms.getWorldTransform( tmpTrans );
                    let p = tmpTrans.getOrigin();
                    let q = tmpTrans.getRotation();
                    objThree.position.set( p.x(), p.y(), p.z() );
                    objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
                }
            }
        }
    </script>
</body>
</html>